# Leetcode 198 House Robber

這題主要是一連串搶與不搶的選擇，是費波那契的延伸題目，假如利用 DP 來思考的話，多用一個 array 來裝已經比較過的值，因為前面已經加進來過了，然後 dp 都會比較最後兩個誰是最大的，所以放在最後面的一定會是到目前第 i 個比較出來最大的數字，所以最後再比較最後的大小就好，有點像是不用管前面到底強的是多大，只要管 dp[i-1] 和 dp[i-2] 會是最佳解，因為必須跳過前一個，所以才會是 dp[i-2] + nums[i]

```
nums = [2,7,9,3,1]

// 一開始 dp 裡面就裝了第一個值和前兩個值最大的值，像是 [ 2, 7 ] 就會是 [ 2, 7 ]，

// 假如是 [ 7, 2 ] 就會是 [ 7, 7 ]，因為第一個是 7 第二個是 2，但是前兩項的最大值會是 7，所以就會是裝 [ 7, 7 ]，這樣在後面比大小的時候， 7 加上跳過第二個的 9 的時候才會是最大值，因為這邊 2 已經不用考慮了，他已經不是最大值了所以就不會納入這個 dp 考量，

// 有點像是把前面累加的最大的把它裝進 dp 裡面，這樣就就會是 O(N)，走到哪裡就可以考慮哪裡的大小
```

```python
    def rob(self, nums: List[int]) -> int:
        if len(nums) == 1:
            return nums[0]
        dp = [nums[0], max(nums[0], nums[1])]
        for i range(2, len(nums)):
            dp.append(max(dp(i-2)+nums[i], dp(i-1)))

        return dp[len(nums) -1 ]
```

```
dp = [ 2, 7 ]

i = 2
max(nums[2]+dp[0],dp[1])
(9+2, 7)
=> 11
dp = [ 2, 7, 11 ]

max(nums[3]+dp[1],dp[2])
(3+7, 11)
=> 11
dp = [ 2, 7, 11, 11 ]

max(nums[4]+dp[2],dp[3])
(1+11, 10)
=> 12
dp = [ 2, 7, 11, 11, 12 ]

```
